<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web 3D Builder - Suite Completa (GIS/CAD/3D)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.min.js"></script>

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        /* --- ESTILO GERAL E RESET --- */
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background-color: #1b1b1b; color: #ddd; font-family: 'Segoe UI', sans-serif; width: 100vw; height: 100vh; }
        
        /* ONDE O 3D ACONTECE */
        #viewport { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: #202020; transition: background 0.3s; }
        
        /* --- CAIXA DE SELEÇÃO --- */
        #selection-box {
            position: absolute;
            border: 2px dashed #00ff00;
            background-color: rgba(0, 255, 0, 0.1);
            display: none;
            z-index: 100;
            pointer-events: none; 
        }

        /* --- BOTÃO MENU HAMBÚRGUER --- */
        #menu-toggle {
            position: absolute; top: 15px; left: 15px; z-index: 10;
            background: #D4AF37; color: #000; border: none;
            width: 45px; height: 45px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
        }
        #menu-toggle:active { transform: scale(0.95); }

        /* --- BARRA LATERAL (SIDEBAR) --- */
        #sidebar {
            position: absolute; top: 0; left: 0; bottom: 0; width: 320px;
            background: rgba(35, 35, 35, 0.98); border-right: 1px solid #555; z-index: 9;
            display: flex; flex-direction: column; 
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            transform: translateX(0); /* Aberto por padrão */
            box-shadow: 5px 0 15px rgba(0,0,0,0.5);
        }
        
        #sidebar.closed { transform: translateX(-110%); }
        .sidebar-spacer { height: 70px; } 

        .panel-header { padding: 20px; background: #2a2a2a; border-bottom: 1px solid #444; font-weight: bold; color: #D4AF37; display: flex; align-items: center; gap: 10px; font-size: 1.1rem; }
        .panel-content { flex: 1; overflow-y: auto; padding: 15px; }
        
        /* --- BOTÕES E ELEMENTOS --- */
        .section-title { font-size: 0.75rem; color: #888; margin: 20px 0 10px 0; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }
        
        .btn {
            background: #444; color: #fff; border: 1px solid #555; padding: 12px; width: 100%;
            margin-bottom: 8px; cursor: pointer; border-radius: 6px; text-align: left;
            display: flex; align-items: center; transition: 0.2s; font-size: 0.9rem;
        }
        .btn:hover { background: #555; border-color: #777; }
        .btn:active { background: #333; }
        
        .btn.primary { background: #D4AF37; color: #000; font-weight: bold; justify-content: center; margin-top: 10px; border: none; }
        .btn.primary:hover { background: #e5c14f; }

        /* GRID DE AMBIENTE */
        .env-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 15px; }
        .env-btn {
            background: #333; border: 1px solid #444; color: #ccc; padding: 8px; font-size: 0.75rem;
            cursor: pointer; border-radius: 4px; text-align: center;
        }
        .env-btn:hover { background: #444; }
        .env-btn.active { background: #D4AF37; color: #000; font-weight: bold; border-color: #D4AF37; }

        /* GRID DE PRIMITIVAS */
        .primitives-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .btn-prim { 
            flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 15px;
            background: #333;
        }
        .btn-prim span.material-icons { font-size: 28px; margin-bottom: 5px; color: #D4AF37; }
        .btn-prim:hover { background: #444; }

        /* LISTA DE ASSETS */
        .asset-item {
            display: flex; align-items: center; justify-content: space-between;
            background: #252525; padding: 8px; margin-bottom: 5px; border-radius: 4px; border: 1px solid #444; 
        }
        .asset-item:hover { border-color: #D4AF37; }
        .asset-clickable { display: flex; align-items: center; cursor: pointer; flex: 1; overflow: hidden; padding: 5px; }
        .asset-item span.text { margin-left: 10px; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .asset-icon { color: #D4AF37; }
        .btn-delete-asset {
            background: transparent; border: none; color: #ff5555; cursor: pointer; padding: 8px;
            display: flex; align-items: center; justify-content: center; transition: 0.2s;
        }
        .btn-delete-asset:hover { background: rgba(255, 0, 0, 0.2); border-radius: 4px; }

        /* PAINEL DE PROPRIEDADES */
        .props-panel { background: #2a2a2a; padding: 10px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #444; }
        .prop-row { display: flex; align-items: center; margin-bottom: 8px; }
        .prop-label { width: 70px; font-size: 0.8rem; color: #ccc; }
        .prop-inputs { display: flex; gap: 5px; flex: 1; }
        .prop-input { 
            width: 100%; background: #111; border: 1px solid #444; color: #fff; 
            padding: 6px; border-radius: 4px; font-size: 0.85rem; text-align: center;
        }
        .prop-input:focus { border-color: #D4AF37; outline: none; }
        
        /* ESTILO PARA INPUT DE ALTURA */
        .height-control { border: 1px solid #D4AF37; background: #2a2200; }

        /* --- TEXTURAS --- */
        .texture-category { margin-bottom: 15px; }
        .tex-cat-title { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; border-left: 2px solid #D4AF37; padding-left: 8px; }
        .texture-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .tex-btn {
            width: 100%; padding-bottom: 80%;
            position: relative; border-radius: 6px; border: 2px solid #444; cursor: pointer;
            background-size: cover; background-position: center; transition: 0.2s; background-color: #000;
        }
        .tex-btn:hover { border-color: #fff; transform: scale(1.05); }
        .tex-btn.active { border-color: #D4AF37; box-shadow: 0 0 8px rgba(212, 175, 55, 0.5); }
        .tex-btn:hover::after {
            content: attr(data-label);
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8); color: white; font-size: 0.65rem; padding: 2px;
            text-align: center; white-space: nowrap; overflow: hidden;
            border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;
        }

        /* --- TOOLBAR SUPERIOR (A original) --- */
        #toolbar {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            height: 60px; background: rgba(35, 35, 35, 0.95); border-radius: 12px; z-index: 8;
            display: flex; align-items: center; padding: 0 15px; gap: 8px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            border: 1px solid #555;
            max-width: 95vw; overflow-x: auto;
        }

        /* --- NOVA TOOLBAR GEOJSON / DESENHO (Separada) --- */
        #geojson-toolbar {
            position: absolute; top: 85px; left: 50%; transform: translateX(-50%);
            height: 50px; background: rgba(40, 40, 50, 0.95); border-radius: 12px; z-index: 8;
            display: flex; align-items: center; padding: 0 15px; gap: 8px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            border: 1px solid #666;
            border-top: 3px solid #3498db; /* Azul para diferenciar */
        }
        
        .tool-btn {
            background: transparent; border: 1px solid transparent; color: #ccc;
            width: 40px; height: 40px; border-radius: 8px; cursor: pointer; 
            display: flex; align-items: center; justify-content: center; flex-shrink: 0;
            transition: 0.2s; position: relative;
        }
        .tool-btn:hover { background: #555; color: white; }
        .tool-btn.active { background: #D4AF37; color: #000; box-shadow: 0 0 10px rgba(212, 175, 55, 0.4); }
        .tool-btn.danger.active { background: #ff4444; color: white; box-shadow: 0 0 10px rgba(255, 68, 68, 0.4); }
        .tool-btn.magic.active { background: #9c27b0; color: white; box-shadow: 0 0 10px rgba(156, 39, 176, 0.5); }
        .tool-btn.selection-active { background: #00ff00; color: #000; box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }
        
        .tool-btn.locked-active { background: #4CAF50; color: white; } 
        
        .tool-btn.lock-btn:hover { color: #f39c12; }
        .tool-btn.unlock-btn:hover { color: #2ecc71; }

        /* Estilos específicos para a barra GeoJSON */
        .geo-btn:hover { background: #34495e; color: #3498db; }
        .geo-btn.active { background: #3498db; color: #fff; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
        .geo-btn.snap-active { background: #e67e22; color: #fff; box-shadow: 0 0 10px rgba(230, 126, 34, 0.5); }
        .geo-btn.eraser-active { background: #e74c3c; color: white; box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
        
        /* NOVO: Estilo para botão de Precisão e Arco */
        .geo-btn.precision-active { background: #9b59b6; color: white; box-shadow: 0 0 10px rgba(155, 89, 182, 0.5); }
        .geo-btn.arc-active { background: #1abc9c; color: white; box-shadow: 0 0 10px rgba(26, 188, 156, 0.5); }

        /* Correção específica para o botão Ímã/Snap */
        #tool-snap {
            background-color: rgba(50, 50, 50, 0.8) !important;
            color: #ffffff !important;
            border: 1px solid #777 !important;
            opacity: 1 !important;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 35px;
            min-height: 35px;
        }

        #tool-snap.active {
            background-color: #4CAF50 !important;
            border-color: #4CAF50 !important;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
        }

        .divider { width: 1px; height: 30px; background: #555; margin: 0 8px; }
        
        input[type="file"] { display: none; }

        /* Notificações */
        #status {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 20;
            background: rgba(0,0,0,0.8); color: #fff; padding: 12px 25px; border-radius: 30px;
            display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5); border: 1px solid #444;
            font-size: 0.95rem; pointer-events: none;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 9999;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        .loading-spinner {
            border: 5px solid #333; border-top: 5px solid #D4AF37;
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text { color: #D4AF37; font-size: 1.2rem; font-weight: bold; letter-spacing: 1px; }

        /* --- BOTÃO FLUTUANTE DE CONFIRMAÇÃO --- */
        #btn-confirm-creation, #btn-multi-delete, #btn-finish-poly {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); z-index: 25;
            padding: 15px 30px;
            border-radius: 50px; font-weight: bold; font-size: 1rem; cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none; /* Oculto por padrão */
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            align-items: center; gap: 10px; border: none;
        }
        #btn-confirm-creation { background: #27ae60; color: white; }
        #btn-confirm-creation:hover { background: #2ecc71; transform: translateX(-50%) scale(1.05); }

        #btn-multi-delete {
            background: #ff4444; color: white;
            bottom: 110px;
        }
        #btn-multi-delete:hover { background: #ff2222; transform: translateX(-50%) scale(1.05); }

        #btn-finish-poly { background: #3498db; color: white; bottom: 110px; }
        #btn-finish-poly:hover { background: #2980b9; transform: translateX(-50%) scale(1.05); }

        @keyframes popIn {
            from { opacity: 0; transform: translateX(-50%) scale(0.5); }
            to { opacity: 1; transform: translateX(-50%) scale(1); }
        }

        /* --- NOVO: MODAL DE INPUT DE DISTÂNCIA --- */
        #length-input-modal {
            position: absolute; top: 150px; left: 50%; transform: translateX(-50%);
            background: #2a2a2a; padding: 15px; border-radius: 8px; border: 1px solid #D4AF37;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6); z-index: 999; display: none;
            display: none; flex-direction: column; gap: 10px; min-width: 250px;
        }
        #length-input-modal label { color: #D4AF37; font-weight: bold; font-size: 0.9rem; }
        #length-input-value {
            background: #111; border: 1px solid #555; color: white; padding: 8px;
            border-radius: 4px; font-size: 1rem;
        }
        #length-input-value:focus { border-color: #D4AF37; outline: none; }
        #length-confirm-btn {
            background: #D4AF37; color: #000; border: none; padding: 10px;
            font-weight: bold; border-radius: 4px; cursor: pointer;
        }
        #length-confirm-btn:hover { background: #e5c14f; }

        hr { border: 0; border-top: 1px solid #444; margin: 15px 0; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-msg">PROCESSANDO...</div>
    </div>

    <div id="length-input-modal" style="display:none;">
        <label>Definir Comprimento (metros):</label>
        <input type="number" id="length-input-value" step="0.1" placeholder="Ex: 1.5">
        <button id="length-confirm-btn" onclick="submitLengthInput()">CONFIRMAR LINHA</button>
        <button style="margin-top:5px; background:transparent; border:1px solid #555; color:#aaa; padding:5px; border-radius:4px; cursor:pointer;" onclick="closeLengthInput()">Cancelar</button>
    </div>

    <div id="selection-box"></div>

    <button id="menu-toggle" onclick="toggleSidebar()">
        <span class="material-icons">menu</span>
    </button>

    <div id="sidebar">
        <div class="sidebar-spacer"></div>
        <div class="panel-header">
            <span class="material-icons">apartment</span> EDITOR 3D PRO
        </div>
        
        <div class="panel-content">

            <div class="section-title">Ambiente / Mapa</div>
            <div class="env-grid">
                <div class="env-btn active" id="env-default" onclick="setEnvironment('default')">Padrão</div>
                <div class="env-btn" id="env-light" onclick="setEnvironment('light')">Mapa Claro</div>
                <div class="env-btn" id="env-sat" onclick="setEnvironment('satellite')">Satélite</div>
            </div>

            <div id="properties-container" style="display:none;">
                <div class="section-title">Propriedades</div>
                <div class="props-panel">
                    
                    <div class="prop-row" id="row-extrusion" style="display:none;">
                        <span class="prop-label" style="color:#D4AF37; font-weight:bold;">Altura</span>
                        <div class="prop-inputs">
                            <input type="number" step="0.1" min="0.01" class="prop-input height-control" id="inp-extrusion" onchange="updateExtrusionHeight()" placeholder="Altura (m)">
                        </div>
                    </div>

                    <div class="prop-row">
                        <span class="prop-label">Escala</span>
                        <div class="prop-inputs">
                            <input type="number" step="0.1" class="prop-input" id="inp-sx" onchange="updateTransform('scale')" placeholder="X">
                            <input type="number" step="0.1" class="prop-input" id="inp-sy" onchange="updateTransform('scale')" placeholder="Y">
                            <input type="number" step="0.1" class="prop-input" id="inp-sz" onchange="updateTransform('scale')" placeholder="Z">
                        </div>
                    </div>
                     <div class="prop-row">
                        <span class="prop-label">Posição</span>
                        <div class="prop-inputs">
                            <input type="number" step="0.5" class="prop-input" id="inp-px" onchange="updateTransform('pos')" placeholder="X">
                            <input type="number" step="0.5" class="prop-input" id="inp-py" onchange="updateTransform('pos')" placeholder="Y">
                            <input type="number" step="0.5" class="prop-input" id="inp-pz" onchange="updateTransform('pos')" placeholder="Z">
                        </div>
                    </div>
                </div>

                <div class="section-title">Materiais & Texturas (Realistas)</div>
                <div id="texture-panel" class="props-panel">
                    </div>
                <hr>
            </div>

            <div class="section-title">Adicionar Primitivas</div>
            <div class="primitives-grid">
                <button class="btn btn-prim" onclick="addPrimitive('cube')">
                    <span class="material-icons">check_box_outline_blank</span> Cubo
                </button>
                <button class="btn btn-prim" onclick="addPrimitive('sphere')">
                    <span class="material-icons">circle</span> Esfera
                </button>
                <button class="btn btn-prim" onclick="addPrimitive('cylinder')">
                    <span class="material-icons">data_usage</span> Cilindro
                </button>
                <button class="btn btn-prim" onclick="addPrimitive('plane')">
                    <span class="material-icons">crop_square</span> Área/Chão
                </button>
            </div>

            <hr>

            <div class="section-title">Importar Arquivos</div>

<button class="btn" onclick="document.getElementById('fileReference').click()">
    <span class="material-icons" style="margin-right:10px; color:#D4AF37;">map</span> Gabarito (GeoJSON)
</button>
<input type="file" id="fileReference" style="display:none;" onchange="handleFileSelect(this, 'ref')">

            <button class="btn" onclick="triggerFile('filePDF')">
                <span class="material-icons" style="margin-right:10px; color:#ff4444;">picture_as_pdf</span> Gabarito PDF
            </button>
            <input type="file" id="filePDF" accept=".pdf" onchange="handleFileSelect(this, 'pdf')">

            <button class="btn" onclick="triggerFile('fileDXF')">
                <span class="material-icons" style="margin-right:10px; color:#2ecc71;">architecture</span> Gabarito CAD (DXF)
            </button>
            <input type="file" id="fileDXF" accept=".dxf" onchange="handleFileSelect(this, 'dxf')">
            
            <button class="btn" onclick="triggerFile('fileModel')">
                <span class="material-icons" style="margin-right:10px; color:#D4AF37;">library_add</span> Modelo 3D (.glb)
            </button>
            <input type="file" id="fileModel" accept=".glb,.gltf" onchange="handleFileSelect(this, 'model')">

            <div class="section-title">Biblioteca da Cena</div>
            <div id="assetLibrary">
                <div style="text-align:center; color:#666; font-size:0.8rem; padding:10px;">Nenhum modelo importado</div>
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid #444; background: #252525;">
            <button class="btn primary" onclick="exportScene()">
                <span class="material-icons" style="margin-right:8px">save_alt</span> EXPORTAR OTIMIZADO
            </button>
        </div>
    </div>

    <div id="toolbar">
        <button class="tool-btn" id="tool-undo" title="Desfazer (Ctrl+Z)" onclick="undo()">
            <span class="material-icons">undo</span>
        </button>
        <button class="tool-btn" id="tool-redo" title="Refazer (Ctrl+Y)" onclick="redo()">
            <span class="material-icons">redo</span>
        </button>

        <div class="divider"></div>
        
        <button class="tool-btn lock-btn" title="Travar Seleção (Impede Seleção)" onclick="lockSelectedObject()">
            <span class="material-icons">lock</span>
        </button>
        <button class="tool-btn unlock-btn" title="Destravar Tudo (Libera Edição)" onclick="unlockAllObjects()">
            <span class="material-icons">lock_open</span>
        </button>
        
        <div class="divider"></div>

        <button class="tool-btn active" id="tool-translate" title="Mover (G)" onclick="setMode('translate')">
            <span class="material-icons">open_with</span>
        </button>
        <button class="tool-btn" id="tool-rotate" title="Rotacionar Livre (R)" onclick="setMode('rotate')">
            <span class="material-icons">rotate_left</span>
        </button>
        
        <button class="tool-btn" id="tool-rotate-y" title="Rotacionar no Chão (Eixo Y)" onclick="setMode('rotate-y')">
            <span class="material-icons">360</span>
        </button>

        <button class="tool-btn" id="tool-scale" title="Escalar (S)" onclick="setMode('scale')">
            <span class="material-icons">aspect_ratio</span>
        </button>
        
        <div class="divider"></div>

        <button class="tool-btn" id="tool-center" title="Centralizar Objeto" onclick="centerSelectedObject()">
            <span class="material-icons">filter_center_focus</span>
        </button>

        <div class="divider"></div>
        
        <button class="tool-btn" id="tool-box-select" title="Seleção em Área (Arrastar para Selecionar)" onclick="toggleBoxSelect()">
            <span class="material-icons">select_all</span>
        </button>

        <div class="divider"></div>

        <button class="tool-btn magic" id="tool-magic" title="Selecionar Área do GeoJSON (Criar Chão/Extrusão)" onclick="toggleMagicMode()">
            <span class="material-icons">auto_fix_high</span>
        </button>

        <button class="tool-btn" id="tool-deep-select" title="Modo Edição Interna (Mover partes)" onclick="toggleDeepSelect()">
            <span class="material-icons">layers</span>
        </button>

        <div class="divider"></div>

        <button class="tool-btn" id="tool-lock-y" title="Travar Movimento no Chão" onclick="toggleLockY()">
            <span class="material-icons">vertical_align_bottom</span>
        </button>
        
        <div class="divider"></div>
        
        <button class="tool-btn" title="Duplicar (Ctrl+D)" onclick="duplicateSelected()">
            <span class="material-icons">content_copy</span>
        </button>
        <button class="tool-btn" title="Deletar (Del)" onclick="deleteSelected()">
            <span class="material-icons" style="color: #ff5555">delete</span>
        </button>
    </div>

    <div id="geojson-toolbar">
    <div style="font-size: 0.8rem; color: #aaa; margin-right: 5px; font-weight: bold;">GABARITO:</div>
    
    <button class="tool-btn geo-btn" id="tool-snap" title="Ativar Ímã (Snap em Vértices)" onclick="toggleSnapMode()">
        <span class="material-icons">magnet_alt</span>
    </button>
    
    <button class="tool-btn geo-btn" id="tool-draw-poly" title="Criar Polígono (Desenhar)" onclick="toggleDrawMode()">
        <span class="material-icons">mode_edit</span>
    </button>
    
    <button class="tool-btn geo-btn" id="tool-length-input" title="Linha com Medida (Régua)" onclick="toggleLengthMode()">
        <span class="material-icons">straighten</span>
    </button>

    <button class="tool-btn geo-btn" id="tool-draw-arc" title="Desenhar Arco (3 Pontos)" onclick="toggleArcMode()">
        <span class="material-icons">gesture</span>
    </button>
    
    <button class="tool-btn geo-btn" id="tool-eraser" title="Borracha (Apagar objeto individual)" onclick="toggleEraserMode()">
        <span class="material-icons" style="color: #e74c3c;">auto_delete</span>
    </button>

    <div class="divider"></div>

    <button class="tool-btn geo-btn" title="Desfazer Último Ponto (Enquanto desenha)" onclick="undoLastDrawPoint()">
        <span class="material-icons" style="color: #f39c12;">undo</span>
    </button>

    <button class="tool-btn geo-btn" title="Excluir Todo o Gabarito/Desenho" onclick="clearAllGeoJSON()">
        <span class="material-icons" style="color: #ff4444;">delete_forever</span>
    </button>
    <div class="divider"></div>

    <button class="tool-btn geo-btn" title="Exportar GeoJSON Criado" onclick="exportCreatedGeoJSON()">
        <span class="material-icons" style="color: #3498db;">save</span>
    </button>
</div>

    <button id="btn-confirm-creation" onclick="confirmCreation()">
        <span class="material-icons">check_circle</span> CONFIRMAR CRIAÇÃO
    </button>
    
    <button id="btn-multi-delete" onclick="deleteMultiSelected()">
        <span class="material-icons">delete_sweep</span> DELETAR SELEÇÃO
    </button>
    
    <button id="btn-finish-poly" onclick="finishPolygon()">
        <span class="material-icons">done_all</span> FINALIZAR POLÍGONO
    </button>

    <div id="viewport"></div>
    <div id="status">Pronto</div>

    <script>
        // --- CONFIGURAÇÃO PDF.js WORKER ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // --- Variáveis Globais ---
        let scene, camera, renderer, orbit, transformControl;
        let objectsGroup, mapPlane;
        let geoJsonGhostGroup; 
        let gridHelper;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let loadedAssets = {}; 
        let selectedObject = null;
        let lockY = false; 
        let deepSelectMode = false;
        let magicMode = false;

        // Variáveis para Seleção em Caixa
        let boxSelectMode = false;
        let isBoxSelecting = false;
        let boxStartPoint = { x: 0, y: 0 };
        let boxSelectionDiv = document.getElementById('selection-box');
        let multiSelectedObjects = []; 
        let selectionHelpers = []; // Visual helpers

        // Variáveis para o sistema de Preview/Confirmação
        let previewMesh = null; 
        let pendingGhost = null; 

        // SISTEMA DE UNDO/REDO (OTIMIZADO)
        let historyStack = [];
        let historyStep = -1;
        const MAX_HISTORY = 8; 

        // --- VARIÁVEIS DO NOVO MODO DE DESENHO (GIS) ---
        let drawMode = false;
        let snapMode = false;
        let eraserMode = false; 
        let drawingPoints = [];
        let drawingLines = []; // Array de linhas visuais
        let tempLine = null;   // Linha que segue o mouse
        let snapIndicator = null; // Esfera visual do snap
        let drawnPolygons = []; // Armazena os GeoJSONs criados
        
        // --- NOVAS VARIÁVEIS PARA AS FERRAMENTAS PEDIDAS ---
        let lengthInputMode = false;
        let pendingLengthVector = null; // Direção para onde a linha vai crescer
        let arcDrawMode = false;
        let arcIntermediatePoint = null; // Ponto do meio do arco
        let arcPreviewLine = null;

        init();
        initTextureSystem();
        initSnapSystem();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);
            
            gridHelper = new THREE.GridHelper(50000, 500, 0x555555, 0x333333);
            scene.add(gridHelper);

            const mapGeo = new THREE.PlaneGeometry(50000, 50000);
            const mapMat = new THREE.MeshBasicMaterial({ color: 0x222222, visible: false });
            mapPlane = new THREE.Mesh(mapGeo, mapMat);
            mapPlane.rotation.x = -Math.PI / 2;
            mapPlane.position.y = -0.1; 
            scene.add(mapPlane);

            objectsGroup = new THREE.Group();
            scene.add(objectsGroup); 

            // Grupo para "Fantasmas" (Raycasting)
            geoJsonGhostGroup = new THREE.Group();
            geoJsonGhostGroup.visible = false; 
            scene.add(geoJsonGhostGroup);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 80000);
            camera.position.set(30, 30, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            document.getElementById('viewport').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            
            dirLight.shadow.bias = -0.001;
            dirLight.shadow.normalBias = 0.05;
            
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -500;
            dirLight.shadow.camera.right = 500;
            dirLight.shadow.camera.top = 500;
            dirLight.shadow.camera.bottom = -500;
            scene.add(dirLight);

            orbit = new THREE.OrbitControls(camera, renderer.domElement);
            orbit.dampingFactor = 0.1;
            orbit.enableDamping = true;

            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', (event) => {
                orbit.enabled = !event.value;
                if (event.value === false) {
                    saveHistory();
                }
            });
            transformControl.addEventListener('change', () => {
                if(selectedObject) {
                    updateUIValues();
                }
            });
            scene.add(transformControl);

            window.addEventListener('resize', onWindowResize);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointercancel', onPointerUp);
            
            window.addEventListener('keydown', onKeyDown);
            
            saveHistory();
        }

        // --- SISTEMA DE SNAP E DESENHO ---
        function initSnapSystem() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, depthTest: false });
            snapIndicator = new THREE.Mesh(geometry, material);
            snapIndicator.visible = false;
            snapIndicator.renderOrder = 9999;
            scene.add(snapIndicator);
        }

        function toggleSnapMode() {
            snapMode = !snapMode;
            const btn = document.getElementById('tool-snap');
            if(snapMode) {
                btn.classList.add('snap-active');
                showStatus("ÍMÃ ATIVADO: Detectando vértices.");
            } else {
                btn.classList.remove('snap-active');
                snapIndicator.visible = false;
                showStatus("Ímã desativado.");
            }
        }

        function toggleEraserMode() {
            eraserMode = !eraserMode;
            const btn = document.getElementById('tool-eraser');
            
            if(eraserMode) {
                btn.classList.add('eraser-active');
                // Desativa outros modos para evitar conflito
                if(drawMode) toggleDrawMode();
                if(magicMode) toggleMagicMode();
                deselect();
                showStatus("MODO BORRACHA: Clique em um polígono para apagar.");
            } else {
                btn.classList.remove('eraser-active');
                showStatus("Borracha desativada.");
            }
        }

        function toggleDrawMode() {
            drawMode = !drawMode;
            const btn = document.getElementById('tool-draw-poly');
            
            // Lógica alterada: PAUSA/RESUME (Estilo QGIS)
            if(drawMode) {
                btn.classList.add('active');
                deselect();
                if(magicMode) toggleMagicMode();
                if(boxSelectMode) toggleBoxSelect();
                if(eraserMode) toggleEraserMode();
                orbit.enableRotate = true; 
                
                if (drawingPoints.length > 0) {
                     showStatus("CONTINUANDO DESENHO. Clique para adicionar pontos.");
                } else {
                     showStatus("MODO DESENHO: Clique para criar pontos.");
                }
            } else {
                btn.classList.remove('active');
                // Desativa as sub-ferramentas ao sair do modo desenho
                if (lengthInputMode) toggleLengthMode();
                if (arcDrawMode) toggleArcMode();
                
                if(tempLine) {
                    scene.remove(tempLine);
                    tempLine = null;
                }
                showStatus("Desenho PAUSADO. Mova a câmera e reative para continuar.");
            }
        }

        // --- NOVAS FUNÇÕES: MODO RÉGUA E ARCO ---
        function toggleLengthMode() {
            if (!drawMode) {
                showStatus("Ative o MODO DE DESENHO (Lápis) primeiro!");
                return;
            }
            lengthInputMode = !lengthInputMode;
            
            // Se ativar régua, desativa arco
            if(lengthInputMode && arcDrawMode) toggleArcMode();

            const btn = document.getElementById('tool-length-input');
            if (lengthInputMode) {
                btn.classList.add('precision-active');
                showStatus("RÉGUA ATIVA: Aponte a direção, clique e digite o valor.");
            } else {
                btn.classList.remove('precision-active');
                showStatus("Régua desativada. Voltando ao desenho livre.");
            }
        }

        function toggleArcMode() {
            if (!drawMode) {
                showStatus("Ative o MODO DE DESENHO (Lápis) primeiro!");
                return;
            }
            arcDrawMode = !arcDrawMode;
            arcIntermediatePoint = null; // Reset
            
            // Se ativar arco, desativa régua
            if(arcDrawMode && lengthInputMode) toggleLengthMode();

            const btn = document.getElementById('tool-draw-arc');
            if (arcDrawMode) {
                btn.classList.add('arc-active');
                showStatus("ARCO ATIVO: Clique no Meio da curva, depois no Fim.");
            } else {
                btn.classList.remove('arc-active');
                // Limpa preview do arco se existir
                if (arcPreviewLine) { scene.remove(arcPreviewLine); arcPreviewLine = null; }
                showStatus("Arco desativado.");
            }
        }

        function closeLengthInput() {
            document.getElementById('length-input-modal').style.display = 'none';
            pendingLengthVector = null;
        }

        function submitLengthInput() {
            const val = parseFloat(document.getElementById('length-input-value').value);
            if (isNaN(val) || val <= 0 || !pendingLengthVector || drawingPoints.length === 0) {
                showStatus("Valor inválido.");
                return;
            }
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            // Calcula o novo ponto: PontoAnterior + (VetorDireção * Comprimento)
            const newPoint = new THREE.Vector3().copy(lastPoint).add(pendingLengthVector.multiplyScalar(val));
            
            addDrawPoint(newPoint);
            closeLengthInput();
            showStatus(`Segmento de ${val}m criado!`);
        }

        function getMousePositionOnPlane(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const planeNormal = new THREE.Vector3(0, 1, 0);
            const planeConstant = 0;
            const plane = new THREE.Plane(planeNormal, planeConstant);
            const target = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, target);
            return target;
        }

        function findSnapPoint(position) {
            if(!snapMode) return position;

            const threshold = 1.0; 
            let closestPoint = null;
            let minDistance = threshold;

            objectsGroup.traverse((obj) => {
                if(obj.isLine || obj.isLineSegments) {
                    const posAttr = obj.geometry.attributes.position;
                    const worldMatrix = obj.matrixWorld;
                    
                    for(let i=0; i<posAttr.count; i++) {
                        const vertex = new THREE.Vector3();
                        vertex.fromBufferAttribute(posAttr, i);
                        vertex.applyMatrix4(worldMatrix);

                        const dist = Math.sqrt(
                            Math.pow(position.x - vertex.x, 2) + 
                            Math.pow(position.z - vertex.z, 2)
                        );

                        if(dist < minDistance) {
                            minDistance = dist;
                            closestPoint = vertex;
                        }
                    }
                }
            });

            if(closestPoint) {
                snapIndicator.position.copy(closestPoint);
                snapIndicator.visible = true;
                return closestPoint;
            } else {
                snapIndicator.visible = false;
                return position;
            }
        }

        function addDrawPoint(point) {
            drawingPoints.push(point.clone());
            
            if(drawingPoints.length > 1) {
                const prev = drawingPoints[drawingPoints.length - 2];
                const curr = drawingPoints[drawingPoints.length - 1];
                
                const geometry = new THREE.BufferGeometry().setFromPoints([prev, curr]);
                const material = new THREE.LineBasicMaterial({ color: 0x3498db, linewidth: 2, depthTest: false });
                const line = new THREE.Line(geometry, material);
                line.renderOrder = 999;
                scene.add(line);
                drawingLines.push(line);
            }

            if(drawingPoints.length >= 3) {
                document.getElementById('btn-finish-poly').style.display = 'flex';
            }
        }

        function updateDrawPreview(cursorPoint) {
            if(drawingPoints.length === 0) return;

            const lastPoint = drawingPoints[drawingPoints.length - 1];
            
            if(tempLine) {
                scene.remove(tempLine);
                tempLine = null;
            }

            // Preview diferente se for Modo Arco
            if (arcDrawMode && arcIntermediatePoint) {
                // Se já temos o ponto do meio, mostrar a curva completa até o mouse
                const points = getCurvePoints(lastPoint, arcIntermediatePoint, cursorPoint);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x1abc9c, transparent: true, opacity: 0.8 });
                tempLine = new THREE.Line(geometry, material);
                scene.add(tempLine);
            } else {
                // Preview Linha Reta Padrão
                const geometry = new THREE.BufferGeometry().setFromPoints([lastPoint, cursorPoint]);
                let color = 0x3498db;
                if (lengthInputMode) color = 0x9b59b6; // Roxo se for régua
                if (arcDrawMode) color = 0x1abc9c; // Verde água se for arco (primeira perna)

                const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5, dashSize: 1, gapSize: 0.5 });
                tempLine = new THREE.Line(geometry, material);
                scene.add(tempLine);
            }
        }

        // Função auxiliar para gerar pontos de um arco por 3 pontos (Circular Arc)
        function getCurvePoints(p1, p2, p3, segments = 12) {
            // Se os pontos forem muito próximos ou colineares, retorna linha reta
            const points = [];
            
            // Método Bézier Quadrático Aproximado (Mais estável que círculo perfeito para UI)
            // P1 = Inicio, P2 = Controle (Aprox), P3 = Fim.
            // Para fazer a curva passar PELO P2, P2 precisa ser ajustado.
            // Fórmula do Ponto no Tempo 0.5 de BezierQuad: B(0.5) = 0.25*P0 + 0.5*Pc + 0.25*P2
            // Queremos que B(0.5) seja nosso p2 clicado.
            // Então: UserP2 = 0.25*P1 + 0.5*ControlP + 0.25*P3
            // 0.5*ControlP = UserP2 - 0.25*P1 - 0.25*P3
            // ControlP = 2*UserP2 - 0.5*P1 - 0.5*P3
            
            const controlPoint = new THREE.Vector3()
                .copy(p2).multiplyScalar(2)
                .sub(p1.clone().multiplyScalar(0.5))
                .sub(p3.clone().multiplyScalar(0.5));

            const curve = new THREE.QuadraticBezierCurve3(p1, controlPoint, p3);
            return curve.getPoints(segments);
        }

        function cancelDrawing() {
            drawingLines.forEach(l => scene.remove(l));
            if(tempLine) scene.remove(tempLine);
            drawingLines = [];
            drawingPoints = [];
            tempLine = null;
            document.getElementById('btn-finish-poly').style.display = 'none';
        }

        function finishPolygon() {
            if(drawingPoints.length < 3) return;

            const first = drawingPoints[0];
            const last = drawingPoints[drawingPoints.length - 1];
            const geometry = new THREE.BufferGeometry().setFromPoints([last, first]);
            const material = new THREE.LineBasicMaterial({ color: 0x3498db });
            const closureLine = new THREE.Line(geometry, material);
            scene.add(closureLine);
            drawingLines.push(closureLine);

            const shape = new THREE.Shape();
            shape.moveTo(drawingPoints[0].x, -drawingPoints[0].z); 
            for(let i=1; i<drawingPoints.length; i++) {
                shape.lineTo(drawingPoints[i].x, -drawingPoints[i].z);
            }
            shape.autoClose = true;

            const shapeGeom = new THREE.ShapeGeometry(shape);
            const ghostMesh = new THREE.Mesh(shapeGeom, new THREE.MeshBasicMaterial({ visible: false }));
            ghostMesh.rotation.x = -Math.PI / 2;
            ghostMesh.position.y = 0;
            ghostMesh.userData.originalShape = shape;
            ghostMesh.userData.area = THREE.ShapeUtils.area(shape.getPoints());
            ghostMesh.userData.isDrawn = true; 
            
            geoJsonGhostGroup.add(ghostMesh);

            const polyGeom = new THREE.ShapeGeometry(shape);
            const polyMat = new THREE.MeshBasicMaterial({ color: 0x3498db, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const polyMesh = new THREE.Mesh(polyGeom, polyMat);
            polyMesh.rotation.x = -Math.PI / 2;
            polyMesh.position.y = 0.02; 
            
            // Salva referência do ghost no mesh visual para a borracha funcionar
            polyMesh.userData.isDrawn = true;
            polyMesh.userData.ghostUUID = ghostMesh.uuid;

            objectsGroup.add(polyMesh);

            drawnPolygons.push({
                points: drawingPoints.map(p => ({x: p.x, z: p.z})),
                uuid: polyMesh.uuid,
                ghostUuid: ghostMesh.uuid
            });

            showStatus("Polígono criado! Use a VARINHA para subir as paredes.");
            
            // Limpa APENAS as linhas visuais do desenho, mantendo o polígono
            drawingLines.forEach(l => scene.remove(l)); 
            if(tempLine) scene.remove(tempLine);
            drawingLines = [];
            drawingPoints = [];
            tempLine = null;
            document.getElementById('btn-finish-poly').style.display = 'none';

            saveHistory();
        }

        function exportCreatedGeoJSON() {
            if(drawnPolygons.length === 0) {
                showStatus("Nenhum polígono desenhado para exportar.");
                return;
            }

            const features = drawnPolygons.map(poly => {
                const coords = poly.points.map(p => [p.x, -p.z]); 
                coords.push(coords[0]);

                return {
                    type: "Feature",
                    properties: {},
                    geometry: {
                        type: "Polygon",
                        coordinates: [coords]
                    }
                };
            });

            const geoJson = {
                type: "FeatureCollection",
                features: features
            };

            const str = JSON.stringify(geoJson, null, 2);
            const blob = new Blob([str], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'meu_gabarito_desenhado.geojson';
            a.click();
            showStatus("GeoJSON exportado!");
        }

        function saveHistory() {
            if (historyStep < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyStep + 1);
            }
            
            const json = objectsGroup.toJSON();
            historyStack.push(JSON.stringify(json));
            
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            } else {
                historyStep++;
            }
            updateUndoRedoUI();
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreHistoryState(historyStack[historyStep]);
                showStatus("Desfazer realizado");
            }
            updateUndoRedoUI();
        }

        function redo() {
            if (historyStep < historyStack.length - 1) {
                historyStep++;
                restoreHistoryState(historyStack[historyStep]);
                showStatus("Refazer realizado");
            }
            updateUndoRedoUI();
        }

        function restoreHistoryState(jsonString) {
            deselect();
            clearMultiSelection(); 

            while(objectsGroup.children.length > 0){ 
                const obj = objectsGroup.children[0];
                objectsGroup.remove(obj); 
                if(obj.traverse) {
                    obj.traverse(child => {
                        if(child.geometry) child.geometry.dispose();
                        if(child.material) {
                            if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                            else child.material.dispose();
                        }
                    });
                }
            }
            
            const loader = new THREE.ObjectLoader();
            loader.parse(JSON.parse(jsonString), function (obj) {
                while(obj.children.length > 0) {
                    const child = obj.children[0];
                    obj.remove(child);
                    child.traverse(c => {
                        if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; }
                    });
                    objectsGroup.add(child);
                }
            });
            
            document.getElementById('assetLibrary').innerHTML = '<div style="text-align:center; color:#666; font-size:0.8rem; padding:10px;">Nenhum modelo importado</div>';
        }

        function updateUndoRedoUI() {
            document.getElementById('tool-undo').style.opacity = historyStep > 0 ? '1' : '0.3';
            document.getElementById('tool-redo').style.opacity = historyStep < historyStack.length - 1 ? '1' : '0.3';
        }

        function initTextureSystem() {
            const baseUrl = "https://imaponeofficial.github.io/textura/";
            const totalTextures = 30;

            const panel = document.getElementById('texture-panel');
            
            const catDiv = document.createElement('div');
            catDiv.className = 'texture-category';
            catDiv.innerHTML = `<div class="tex-cat-title">Minhas Texturas</div>`;
            
            const grid = document.createElement('div');
            grid.className = 'texture-grid';
            
            for (let i = 1; i <= totalTextures; i++) {
                const url = `${baseUrl}${i}.jpg`;
                
                const btn = document.createElement('div');
                btn.className = 'tex-btn';
                btn.setAttribute('data-label', `Textura ${i}`);
                btn.style.backgroundImage = `url('${url}')`;
                btn.onclick = () => applyTextureToSelection(url);
                grid.appendChild(btn);
            }

            catDiv.appendChild(grid);
            panel.appendChild(catDiv);
        }

        const sharedMaterials = {}; 

        function applyTextureToSelection(url) {
            if(!selectedObject) return;
            
            showStatus("Aplicando textura...");

            automapUVs(selectedObject, true); 

            if (sharedMaterials[url]) {
                selectedObject.traverse((node) => {
                    if (node.isMesh) {
                        node.material = sharedMaterials[url];
                        node.material.needsUpdate = true;
                    }
                });
                showStatus("Textura aplicada (Otimizada)!");
                saveHistory();
                return;
            }

            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');

            loader.load(url, function(texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.encoding = THREE.sRGBEncoding;
                texture.repeat.set(1, 1); 

                const newMat = new THREE.MeshStandardMaterial({
                    map: texture,
                    color: 0xffffff,
                    roughness: 1,
                    metalness: 0
                });

                sharedMaterials[url] = newMat; 

                selectedObject.traverse((node) => {
                    if (node.isMesh) {
                        node.material = newMat;
                        node.material.needsUpdate = true;
                    }
                });
                showStatus("Textura aplicada!");
                saveHistory();
            }, undefined, function(err) {
                console.error("Erro textura", err);
                showStatus("Erro ao carregar imagem.");
            });
        }

        function automapUVs(object, useWorldScale = false) {
            object.traverse((mesh) => {
                if (mesh.isMesh && mesh.geometry) {
                    mesh.geometry.computeVertexNormals();
                    mesh.geometry.computeBoundingBox();
                    
                    const bbox = mesh.geometry.boundingBox;
                    const size = new THREE.Vector3();
                    bbox.getSize(size);
                    const min = bbox.min;

                    const posAttribute = mesh.geometry.attributes.position;
                    const normAttribute = mesh.geometry.attributes.normal;
                    
                    const count = posAttribute.count;
                    const uvs = new Float32Array(count * 2);

                    const scaleFactor = useWorldScale ? 2.0 : 1.0; 

                    for (let i = 0; i < count; i++) {
                        const x = posAttribute.getX(i);
                        const y = posAttribute.getY(i);
                        const z = posAttribute.getZ(i);

                        let nx = 0, ny = 1, nz = 0;
                        if(normAttribute) {
                            nx = normAttribute.getX(i);
                            ny = normAttribute.getY(i);
                            nz = normAttribute.getZ(i);
                        }

                        let u, v;

                        if (Math.abs(ny) > Math.abs(nx) && Math.abs(ny) > Math.abs(nz)) {
                            if (useWorldScale) {
                                u = (x - min.x) / scaleFactor;
                                v = (z - min.z) / scaleFactor;
                            } else {
                                u = (x - min.x) / size.x;
                                v = (z - min.z) / size.z;
                            }
                        } 
                        else if (Math.abs(nx) > Math.abs(ny) && Math.abs(nx) > Math.abs(nz)) {
                            if (useWorldScale) {
                                u = (z - min.z) / scaleFactor;
                                v = (y - min.y) / scaleFactor;
                            } else {
                                u = (z - min.z) / size.z;
                                v = (y - min.y) / size.y;
                            }
                        } 
                        else {
                            if (useWorldScale) {
                                u = (x - min.x) / scaleFactor;
                                v = (y - min.y) / scaleFactor;
                            } else {
                                u = (x - min.x) / size.x;
                                v = (y - min.y) / size.y;
                            }
                        }

                        uvs[i * 2] = u;
                        uvs[i * 2 + 1] = v;
                    }

                    mesh.geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                    mesh.geometry.attributes.uv.needsUpdate = true;
                }
            });
        }

        // --- ATUALIZAÇÃO MAPA SATÉLITE ---
        function setEnvironment(mode) {
            document.querySelectorAll('.env-btn').forEach(b => b.classList.remove('active'));
            if (mode === 'default') {
                document.getElementById('env-default').classList.add('active');
                scene.background = new THREE.Color(0x202020);
                gridHelper.visible = true;
                gridHelper.material.color.setHex(0x555555);
                mapPlane.material.visible = false;
                mapPlane.material.map = null;
            } 
            else if (mode === 'light') {
                document.getElementById('env-light').classList.add('active');
                scene.background = new THREE.Color(0xe0e0e0); 
                gridHelper.visible = true;
                gridHelper.material.color.setHex(0xaaaaaa); 
                mapPlane.material.visible = true;
                mapPlane.material.color.setHex(0xf2f2f2); 
                mapPlane.material.map = null;
                mapPlane.material.needsUpdate = true;
            } 
            else if (mode === 'satellite') {
                document.getElementById('env-sat').classList.add('active');
                scene.background = new THREE.Color(0x87CEEB); // Céu azul
                gridHelper.visible = false; 
                
                // Carrega Textura de Satélite (Genérica para evitar bloqueio)
                // Usando uma textura de solo/terra de alta resolução
                const loader = new THREE.TextureLoader();
                const texUrl = "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/terrain/grasslight-big.jpg"; 
                // Alternativa: 'https://images.unsplash.com/photo-1451187580459-43490279c0fa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1080&q=80' (Pode ter CORS)
                // Vamos usar a textura segura do Three.js repo ou uma cor solida com noise se falhar
                
                loader.load(texUrl, function(texture) {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(500, 500); // Repete muito para parecer terreno
                    texture.anisotropy = 16;
                    
                    mapPlane.material.map = texture;
                    mapPlane.material.color.setHex(0xffffff);
                    mapPlane.material.visible = true;
                    mapPlane.material.needsUpdate = true;
                }, undefined, function() {
                     // Fallback se falhar
                     mapPlane.material.color.setHex(0x3b5f2d); // Verde escuro militar
                     mapPlane.material.visible = true;
                });
            }
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('closed');
        }

        function triggerFile(id) {
            document.getElementById(id).click();
        }

        function toggleLockY() {
            lockY = !lockY;
            const btn = document.getElementById('tool-lock-y');
            if (lockY) {
                btn.classList.add('locked-active');
                if (selectedObject) {
                    dropToFloor(selectedObject);
                    showStatus("Travado no chão.");
                } else {
                    showStatus("Modo Chão Ativado");
                }
                transformControl.showY = false;
            } else {
                btn.classList.remove('locked-active');
                transformControl.showY = true;
                showStatus("Movimento livre.");
            }
        }

        function toggleMagicMode() {
            magicMode = !magicMode;
            const btn = document.getElementById('tool-magic');
            
            clearPreview();

            if(magicMode) {
                btn.classList.add('active');
                showStatus("VARINHA MÁGICA: Clique em um GeoJSON ou Polígono desenhado.");
                deselect();
                if(drawMode) toggleDrawMode();
                if(eraserMode) toggleEraserMode();
            } else {
                btn.classList.remove('active');
                showStatus("Modo padrão.");
            }
            if(boxSelectMode) toggleBoxSelect();
        }

        function centerSelectedObject() {
            if (!selectedObject) {
                showStatus("Selecione um objeto primeiro.");
                return;
            }
            selectedObject.position.set(0, selectedObject.position.y, 0);
            updateUIValues();
            showStatus("Objeto centralizado!");
            orbit.target.set(0, selectedObject.position.y, 0);
            saveHistory();
        }

        function dropToFloor(obj) {
            if(!obj) return;
            const box = new THREE.Box3().setFromObject(obj);
            const bottomY = box.min.y;
            const diff = 0 - bottomY;
            obj.position.y += diff;
            updateUIValues();
        }

        function addPrimitive(type) {
            let geometry, material, mesh;
            material = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.6 });
            
            if (type === 'cube') {
                geometry = new THREE.BoxGeometry(2,2,2);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = 1;
            } 
            else if (type === 'sphere') {
                geometry = new THREE.SphereGeometry(1.5, 32, 32);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = 1.5;
            }
            else if (type === 'cylinder') {
                geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = 1;
            }
            else if (type === 'plane') {
                geometry = new THREE.PlaneGeometry(10, 10);
                material = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                mesh.name = "Area_Plot";
            }
            mesh.castShadow = true; mesh.receiveShadow = true;
            spawnObjectDirect(mesh);
        }

        function handleFileSelect(input, type) {
            const file = input.files[0];
            if (!file) return;
            const name = file.name.toLowerCase();

            if (type === 'ref') {
                loadGeoJSON(file);
            } else if (type === 'model') {
                if (name.includes('.glb') || name.includes('.gltf')) {
                    loadGLB(file);
                } else {
                    alert("Use .glb ou .gltf.");
                }
            } else if (type === 'pdf') {
                loadPDF(file);
            } else if (type === 'dxf') {
                loadDXF(file);
            }
            input.value = '';
        }

        function loadPDF(file) {
            showStatus("Processando PDF...");
            const fileReader = new FileReader();
            fileReader.onload = function() {
                const typedarray = new Uint8Array(this.result);
                
                pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
                    pdf.getPage(1).then(function(page) {
                        const scale = 2.0; 
                        const viewport = page.getViewport({ scale: scale });

                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport
                        };

                        page.render(renderContext).promise.then(function() {
                            const texture = new THREE.CanvasTexture(canvas);
                            texture.encoding = THREE.sRGBEncoding;

                            const widthMeters = viewport.width / 50; 
                            const heightMeters = viewport.height / 50;

                            const geometry = new THREE.PlaneGeometry(widthMeters, heightMeters);
                            const material = new THREE.MeshBasicMaterial({ 
                                map: texture, 
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.9
                            });

                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.rotation.x = -Math.PI / 2;
                            mesh.position.y = 0.05; 
                            mesh.name = "Gabarito_PDF";

                            objectsGroup.add(mesh);
                            selectObject(mesh);
                            showStatus("Gabarito PDF importado! Use a caneta para desenhar por cima.");
                            saveHistory();
                        });
                    });
                }).catch(function(error) {
                    console.error('Erro ao ler PDF:', error);
                    showStatus("Erro ao ler PDF.");
                });
            };
            fileReader.readAsArrayBuffer(file);
        }

        function loadDXF(file) {
            showStatus("Lendo arquivo DXF...");
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const parser = new DxfParser();
                    const dxf = parser.parseSync(e.target.result);
                    
                    if(!dxf || !dxf.entities) {
                        showStatus("DXF vazio ou inválido.");
                        return;
                    }

                    const dxfGroup = new THREE.Group();
                    dxfGroup.name = "Gabarito CAD/DXF";
                    const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });

                    dxf.entities.forEach(entity => {
                        if(entity.type === 'LINE') {
                            const points = [];
                            points.push(new THREE.Vector3(entity.vertices[0].x, 0, -entity.vertices[0].y));
                            points.push(new THREE.Vector3(entity.vertices[1].x, 0, -entity.vertices[1].y));
                            const geo = new THREE.BufferGeometry().setFromPoints(points);
                            dxfGroup.add(new THREE.Line(geo, material));
                        }
                        else if(entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {
                            const points = [];
                            if(entity.vertices) {
                                entity.vertices.forEach(v => {
                                    points.push(new THREE.Vector3(v.x, 0, -v.y));
                                });
                                if(entity.shape || (entity.vertices.length > 2 && entity.closed)) {
                                    points.push(points[0]);
                                }
                                const geo = new THREE.BufferGeometry().setFromPoints(points);
                                dxfGroup.add(new THREE.Line(geo, material));
                            }
                        }
                    });

                    const box = new THREE.Box3().setFromObject(dxfGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    dxfGroup.position.x = -center.x;
                    dxfGroup.position.z = -center.z;
                    dxfGroup.position.y = 0.1;

                    objectsGroup.add(dxfGroup);
                    addAssetToList(dxfGroup, "DXF Importado");
                    selectObject(dxfGroup);
                    showStatus("DXF importado! Use o ÍMÃ para desenhar paredes.");
                    saveHistory();

                } catch(err) {
                    console.error(err);
                    showStatus("Erro ao processar DXF.");
                }
            };
            reader.readAsText(file);
        }

        function loadGeoJSON(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const json = JSON.parse(event.target.result);
                    drawGeoJSON(json);
                    showStatus("Mapa carregado! Use a 'Varinha' para selecionar.");
                    saveHistory();
                } catch(err) {
                    console.error(err);
                    showStatus("Erro ao ler JSON.");
                }
            };
            reader.readAsText(file);
        }

        function drawGeoJSON(geojson) {
            const features = geojson.features || (geojson.type === "FeatureCollection" ? geojson.features : [geojson]);
            if(!features || features.length === 0) return;

            const center = findCenterRecursive(features);
            if (!center) {
                showStatus("Erro: Coordenadas inválidas.");
                return;
            }

            const mapGroup = new THREE.Group();
            mapGroup.name = "Mapa Importado (GeoJSON)";

            while(geoJsonGhostGroup.children.length > 0){ 
                geoJsonGhostGroup.remove(geoJsonGhostGroup.children[0]); 
            }

            features.forEach((f) => {
                if(!f.geometry) return;
                const coords = f.geometry.coordinates;
                const type = f.geometry.type;

                const safeLonLat = (c) => {
                    const res = lonLatToXY(c[0], c[1], center);
                    if (isNaN(res[0]) || isNaN(res[1])) return [0,0];
                    return res;
                }

                if (type.includes("Polygon")) {
                    const polygons = type === "MultiPolygon" ? coords : [coords];
                    polygons.forEach((poly) => {
                        const rings = type === "MultiPolygon" ? poly : poly; 
                        const outerRing = rings[0];
                        if (!Array.isArray(outerRing)) return;

                        const points = [];
                        const shape = new THREE.Shape();

                        outerRing.forEach((c, index) => {
                            if (c.length >= 2) {
                                const [x, z] = safeLonLat(c);
                                points.push(new THREE.Vector3(x, 0, z));
                                if (index === 0) shape.moveTo(x, -z); 
                                else shape.lineTo(x, -z);
                            }
                        });

                        shape.autoClose = true;

                        if (points.length > 0) {
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({ color: 0xD4AF37, linewidth: 2 });
                            mapGroup.add(new THREE.Line(geometry, material));
                        }

                        const shapeGeom = new THREE.ShapeGeometry(shape);
                        const area = THREE.ShapeUtils.area(shape.getPoints());
                        
                        const ghostMesh = new THREE.Mesh(shapeGeom, new THREE.MeshBasicMaterial({ visible: false }));
                        ghostMesh.rotation.x = -Math.PI / 2; 
                        ghostMesh.position.y = 0; 
                        
                        ghostMesh.userData.originalShape = shape;
                        ghostMesh.userData.area = Math.abs(area); 
                        
                        geoJsonGhostGroup.add(ghostMesh);
                    });
                }
                else if (type === "LineString") {
                    const points = [];
                    coords.forEach(c => {
                        const [x, z] = safeLonLat(c);
                        points.push(new THREE.Vector3(x, 0, z));
                    });
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    mapGroup.add(new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xAAAAAA })));
                }
            });

            mapGroup.position.y = 0.1; 
            objectsGroup.add(mapGroup);
            addAssetToList(mapGroup, "Mapa GeoJSON");
            
            camera.position.set(0, 100, 100);
            orbit.target.set(0,0,0);
        }

        function previewSelection(ghostMesh) {
            if (previewMesh) {
                scene.remove(previewMesh);
                previewMesh = null;
            }

            pendingGhost = ghostMesh; 
            const shape = ghostMesh.userData.originalShape;

            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.5, 
                side: THREE.DoubleSide,
                depthTest: false 
            });

            previewMesh = new THREE.Mesh(geometry, material);
            previewMesh.rotation.x = -Math.PI / 2;
            previewMesh.position.y = 0.2; 
            previewMesh.renderOrder = 999; 

            scene.add(previewMesh);
            
            const btn = document.getElementById('btn-confirm-creation');
            btn.style.display = 'flex';
            
            showStatus("Objeto identificado! Clique em CONFIRMAR para criar.");
        }

        function clearPreview() {
            if (previewMesh) {
                scene.remove(previewMesh);
                previewMesh = null;
            }
            pendingGhost = null;
            document.getElementById('btn-confirm-creation').style.display = 'none';
        }

        function confirmCreation() {
            if (!pendingGhost) return;
            createExtrusionFromGhost(pendingGhost);
            clearPreview();
            
            showStatus("Objeto Criado! Continue clicando ou desligue a varinha.");
            saveHistory();
        }

        // Procure por esta função no seu código
function createExtrusionFromGhost(ghostMesh) {
    const shape = ghostMesh.userData.originalShape;
    
    const extrudeSettings = {
        steps: 1,
        depth: 0.05, 
        bevelEnabled: false
    };

    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const material = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2; 
    mesh.receiveShadow = true;
    mesh.castShadow = true;
    
    mesh.userData.isExtruded = true;
    mesh.userData.baseShape = shape; 
    
    // --- ADICIONE ESTA LINHA ABAIXO ---
    // Salva os pontos brutos para resistir ao JSON/Undo/Redo
    mesh.userData.shapePoints = shape.getPoints(); 
    // ----------------------------------

    mesh.userData.currentHeight = 0.05;
    
    mesh.position.y = 0.05; 

    objectsGroup.add(mesh);
    selectObject(mesh);
}

        function updateExtrusionHeight() {
    if (!selectedObject || !selectedObject.userData.isExtruded) return;
    
    const val = parseFloat(document.getElementById('inp-extrusion').value);
    if (isNaN(val) || val < 0) return;

    // --- CÓDIGO CORRIGIDO ---
    let shape = selectedObject.userData.baseShape;

    // Se temos os pontos salvos, recriamos o Shape do zero.
    // Isso conserta o erro "t.extractPoints is not a function"
    if (selectedObject.userData.shapePoints) {
        const points = selectedObject.userData.shapePoints.map(p => new THREE.Vector2(p.x, p.y));
        shape = new THREE.Shape(points);
    } 
    // Fallback de segurança: se o shape atual não tiver a função necessária e não tivermos pontos, aborta para não travar
    else if (!shape || typeof shape.extractPoints !== 'function') {
        console.warn("Shape corrompido pelo histórico. Recrie o objeto.");
        return;
    }
    // ------------------------
    
    const newSettings = {
        steps: 1,
        depth: val,
        bevelEnabled: false
    };
    
    const newGeom = new THREE.ExtrudeGeometry(shape, newSettings);
    const currentMat = selectedObject.material;
    
    selectedObject.geometry.dispose();
    selectedObject.geometry = newGeom;
    selectedObject.userData.currentHeight = val;
    
    // Atualiza referência do baseShape para o novo (válido)
    selectedObject.userData.baseShape = shape;

    if(currentMat.map) {
        automapUVs(selectedObject, true);
        currentMat.needsUpdate = true;
    }
    saveHistory();
}

        function findCenterRecursive(obj) {
            if (Array.isArray(obj)) {
                if (obj.length >= 2 && typeof obj[0] === 'number' && typeof obj[1] === 'number') {
                    return obj;
                }
                for (let item of obj) {
                    const found = findCenterRecursive(item);
                    if (found) return found;
                }
            } else if (typeof obj === 'object' && obj !== null) {
                if (obj.geometry) return findCenterRecursive(obj.geometry);
                if (obj.coordinates) return findCenterRecursive(obj.coordinates);
                if (obj.features) return findCenterRecursive(obj.features);
            }
            return null;
        }

        function lonLatToXY(lon, lat, center) {
            if (typeof lon !== 'number' || typeof lat !== 'number') return [0,0];
            const R = 6378137; 
            const dLon = (lon - center[0]) * (Math.PI / 180);
            const latRad = center[1] * (Math.PI / 180);
            const x = dLon * R * Math.cos(latRad);
            const z = (lat - center[1]) * (Math.PI / 180) * R * -1;
            return [x, z];
        }

        function loadGLB(file) {
            const url = URL.createObjectURL(file);
            const loader = new THREE.GLTFLoader();
            showStatus("Carregando modelo...");
            loader.load(url, function(gltf) {
                const model = gltf.scene;
                model.traverse(o => { 
                    if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } 
                });
                const assetName = file.name.replace(/\.(glb|gltf)$/i, '');
                loadedAssets[assetName] = model; 
                addAssetButton(assetName);
                spawnObject(assetName);
                showStatus("Modelo importado!");
            }, undefined, (error) => {
                console.error(error);
                showStatus("Erro ao carregar GLB.");
            });
        }

        function addAssetButton(name) {
            const lib = document.getElementById('assetLibrary');
            if(lib.children[0] && lib.children[0].innerText.includes("Nenhum")) lib.innerHTML = "";
            if(Array.from(lib.children).some(c => c.innerText.includes(name))) return;

            const item = document.createElement('div');
            item.className = 'asset-item';
            item.innerHTML = `
                <div class="asset-clickable" onclick="spawnObject('${name}')">
                    <span class="material-icons asset-icon">inventory_2</span>
                    <span class="text">${name}</span>
                </div>
                <button class="btn-delete-asset" title="Remover" onclick="removeAssetFromLib(this, '${name}')">
                    <span class="material-icons" style="font-size:18px">delete_forever</span>
                </button>
            `;
            lib.appendChild(item);
        }

        function addAssetToList(obj, name) {
            const lib = document.getElementById('assetLibrary');
            if(lib.children[0] && lib.children[0].innerText.includes("Nenhum")) lib.innerHTML = "";
            
            const uniqueID = 'map_' + Date.now();
            obj.userData.listID = uniqueID;

            const item = document.createElement('div');
            item.className = 'asset-item';
            item.id = uniqueID;
            item.innerHTML = `
                <div class="asset-clickable" onclick="selectObjectByID('${obj.uuid}')">
                    <span class="material-icons asset-icon" style="color:#D4AF37;">map</span>
                    <span class="text">${name}</span>
                </div>
                <button class="btn-delete-asset" title="Remover" onclick="deleteObjectByUUID('${obj.uuid}', '${uniqueID}')">
                    <span class="material-icons" style="font-size:18px">delete_forever</span>
                </button>
            `;
            lib.appendChild(item);
        }

        function selectObjectByID(uuid) {
            const obj = objectsGroup.children.find(c => c.uuid === uuid);
            if(obj) selectObject(obj);
        }
        
        function deleteObjectByUUID(uuid, listID) {
            const obj = objectsGroup.children.find(c => c.uuid === uuid);
            if(obj) {
                objectsGroup.remove(obj);
                document.getElementById(listID).remove();
                deselect();
                saveHistory();
            }
        }

        function removeAssetFromLib(btn, name) {
            delete loadedAssets[name];
            btn.parentElement.remove();
            if(document.getElementById('assetLibrary').children.length === 0) {
                document.getElementById('assetLibrary').innerHTML = '<div style="text-align:center; color:#666; font-size:0.8rem; padding:10px;">Nenhum modelo importado</div>';
            }
        }

        function spawnObject(assetName) {
            if (!loadedAssets[assetName]) return;
            const newObj = loadedAssets[assetName].clone();
            spawnObjectDirect(newObj);
        }

        function spawnObjectDirect(obj) {
            const target = orbit.target.clone();
            obj.position.set(target.x, target.y, target.z);
            objectsGroup.add(obj);
            if (lockY) dropToFloor(obj);
            selectObject(obj);
            saveHistory();
        }

        function toggleDeepSelect() {
            deepSelectMode = !deepSelectMode;
            const btn = document.getElementById('tool-deep-select');
            if (deepSelectMode) {
                btn.classList.add('active', 'danger');
                showStatus("MODO GRUPO: Seleção individual ativada.");
                deselect();
            } else {
                btn.classList.remove('active', 'danger');
                showStatus("Modo Padrão");
                deselect();
            }
        }

        function lockSelectedObject() {
            if (!selectedObject) return;
            
            selectedObject.userData.locked = true;
            deselect();
            showStatus("Objeto TRAVADO! Agora você pode clicar através dele.");
        }

        function unlockAllObjects() {
            objectsGroup.traverse(obj => {
                if (obj.userData.locked) {
                    obj.userData.locked = false;
                }
            });
            showStatus("Todos os objetos foram DESTRAVADOS.");
        }

        // --- SISTEMA DE SELEÇÃO EM CAIXA (BOX SELECT) ---
        function toggleBoxSelect() {
            boxSelectMode = !boxSelectMode;
            const btn = document.getElementById('tool-box-select');
            
            deselect();
            clearMultiSelection();

            if (boxSelectMode) {
                btn.classList.add('selection-active');
                showStatus("MODO MÚLTIPLO: Arraste para selecionar vários itens.");
                orbit.enabled = false; 
                if(drawMode) toggleDrawMode(); // Desliga desenho se ativo
                if(eraserMode) toggleEraserMode();
            } else {
                btn.classList.remove('selection-active');
                showStatus("Modo Padrão");
                orbit.enabled = true;
            }
        }

        function onPointerDown(event) {
            if (event.target.closest('.tool-btn') || event.target.closest('#sidebar') || event.target.closest('#menu-toggle') || event.target.closest('#btn-confirm-creation') || event.target.closest('#btn-multi-delete') || event.target.closest('#btn-finish-poly') || event.target.closest('#length-input-modal')) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // MODO DE DESENHO
            if(drawMode) {
                const rawPos = getMousePositionOnPlane(event.clientX, event.clientY);
                if(rawPos) {
                    const finalPos = findSnapPoint(rawPos); 

                    // 1. Lógica do Modo de Medida Exata (Régua)
                    if (lengthInputMode && drawingPoints.length > 0) {
                        const last = drawingPoints[drawingPoints.length-1];
                        const dir = new THREE.Vector3().subVectors(finalPos, last).normalize();
                        
                        // Salva o vetor direção e abre o modal
                        pendingLengthVector = dir;
                        const modal = document.getElementById('length-input-modal');
                        modal.style.display = 'flex';
                        modal.style.left = event.clientX + 'px';
                        modal.style.top = event.clientY + 'px';
                        document.getElementById('length-input-value').focus();
                        return; // Interrompe para esperar o input
                    }

                    // 2. Lógica do Modo Arco
                    if (arcDrawMode && drawingPoints.length > 0) {
                        if (!arcIntermediatePoint) {
                            // Primeiro clique: define o ponto do meio da curva
                            arcIntermediatePoint = finalPos.clone();
                            showStatus("Meio da curva definido. Clique no FIM.");
                        } else {
                            // Segundo clique: define o fim e gera a curva
                            const last = drawingPoints[drawingPoints.length-1];
                            const curvePoints = getCurvePoints(last, arcIntermediatePoint, finalPos);
                            
                            // Adiciona todos os pontos da curva ao array de desenho
                            // Ignora o primeiro porque já é o 'last'
                            for(let i=1; i<curvePoints.length; i++) {
                                addDrawPoint(curvePoints[i]);
                            }
                            
                            arcIntermediatePoint = null; // Reseta para próxima curva
                            if (arcPreviewLine) { scene.remove(arcPreviewLine); arcPreviewLine = null; }
                            showStatus("Arco criado! Continue ou feche.");
                        }
                        return;
                    }

                    addDrawPoint(finalPos);
                }
                return;
            }

            raycaster.setFromCamera(mouse, camera);

            // MODO BORRACHA
            if(eraserMode) {
                const intersects = raycaster.intersectObjects(objectsGroup.children, true);
                
                if(intersects.length > 0) {
                    let target = intersects[0].object;
                    while(target.parent !== objectsGroup && target.parent !== null) {
                        target = target.parent;
                    }
                    if(target.userData.isDrawn || target.userData.ghostUuid) {
                        objectsGroup.remove(target);
                        if(target.geometry) target.geometry.dispose();
                        if(target.userData.ghostUuid) {
                            const ghost = geoJsonGhostGroup.children.find(g => g.uuid === target.userData.ghostUuid);
                            if(ghost) geoJsonGhostGroup.remove(ghost);
                        }
                        drawnPolygons = drawnPolygons.filter(p => p.uuid !== target.uuid);
                        showStatus("Polígono apagado.");
                        saveHistory();
                        return;
                    }
                     const hit = intersects[0].object;
                     if(hit.parent.name === "Mapa Importado (GeoJSON)") {
                         hit.parent.remove(hit);
                         hit.geometry.dispose();
                         showStatus("Linha do mapa apagada.");
                         saveHistory();
                         return;
                     }
                }
                return;
            }

            if (boxSelectMode) {
                isBoxSelecting = true;
                boxStartPoint.x = event.clientX;
                boxStartPoint.y = event.clientY;
                boxSelectionDiv.style.left = event.clientX + 'px';
                boxSelectionDiv.style.top = event.clientY + 'px';
                boxSelectionDiv.style.width = '0px';
                boxSelectionDiv.style.height = '0px';
                boxSelectionDiv.style.display = 'block';
                return;
            }

            if (magicMode) {
                const ghostIntersects = raycaster.intersectObjects(geoJsonGhostGroup.children, true);
                if (ghostIntersects.length > 0) {
                    ghostIntersects.sort((a, b) => {
                        return (a.object.userData.area || 999999) - (b.object.userData.area || 999999);
                    });
                    const smallestObj = ghostIntersects[0].object;
                    previewSelection(smallestObj);
                    return;
                } else {
                    clearPreview();
                }
                return;
            }

            // SELEÇÃO PADRÃO
            const intersects = raycaster.intersectObjects(objectsGroup.children, true);
            if (intersects.length > 0) {
                let target = null;
                for (let i = 0; i < intersects.length; i++) {
                    let candidate = intersects[i].object;
                    let isLocked = false;
                    let p = candidate;
                    while(p !== objectsGroup && p !== null) {
                        if (p.userData.locked) {
                            isLocked = true;
                            break;
                        }
                        p = p.parent;
                    }
                    if (!isLocked) {
                        target = candidate;
                        break;
                    }
                }

                if (target) {
                    if (!deepSelectMode) {
                        while(target.parent !== objectsGroup && target.parent !== null) {
                            if (target.parent.userData.locked) break; 
                            target = target.parent;
                        }
                    }
                    if (target.parent === objectsGroup || deepSelectMode) {
                        selectObject(target);
                    }
                } else {
                    if (!transformControl.dragging) deselect();
                }
            } else {
                if (!transformControl.dragging) deselect();
            }
        }

        function onPointerMove(event) {
            // Preview de Desenho
            if(drawMode) {
                const rawPos = getMousePositionOnPlane(event.clientX, event.clientY);
                if(rawPos) {
                    const finalPos = findSnapPoint(rawPos);
                    updateDrawPreview(finalPos);
                }
                return;
            }

            if (isBoxSelecting && boxSelectMode) {
                const currentX = event.clientX;
                const currentY = event.clientY;
                
                const width = Math.abs(currentX - boxStartPoint.x);
                const height = Math.abs(currentY - boxStartPoint.y);
                const newLeft = Math.min(currentX, boxStartPoint.x);
                const newTop = Math.min(currentY, boxStartPoint.y);
                
                boxSelectionDiv.style.width = width + 'px';
                boxSelectionDiv.style.height = height + 'px';
                boxSelectionDiv.style.left = newLeft + 'px';
                boxSelectionDiv.style.top = newTop + 'px';
            }
        }

        function onPointerUp(event) {
            if (isBoxSelecting && boxSelectMode) {
                isBoxSelecting = false;
                performBoxSelection();
                boxSelectionDiv.style.display = 'none';
            }
        }

        function performBoxSelection() {
            clearMultiSelection();
            const rect = boxSelectionDiv.getBoundingClientRect();
            if (rect.width < 5 || rect.height < 5) return;

            const frustum = new THREE.Frustum();
            const projScreenMatrix = new THREE.Matrix4();
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);

            const candidates = [];
            const parentSet = new Set();
            
            objectsGroup.traverse((obj) => {
                if (obj.isMesh && obj.visible) {
                    let p = obj;
                    let locked = false;
                    while(p) { if(p.userData.locked) locked=true; p=p.parent; }
                    if(!locked) candidates.push(obj);
                }
            });

            candidates.forEach(obj => {
                const pos = new THREE.Vector3();
                obj.getWorldPosition(pos);
                pos.project(camera); 
                
                const x = (pos.x * .5 + .5) * window.innerWidth;
                const y = (-(pos.y * .5) + .5) * window.innerHeight;
                
                if (x >= rect.left && x <= rect.right &&
                    y >= rect.top && y <= rect.bottom) {
                    
                    let target = obj;
                    if (!deepSelectMode) {
                        while(target.parent !== objectsGroup && target.parent !== null) {
                            target = target.parent;
                        }
                    }
                    if(target.parent === objectsGroup || deepSelectMode) {
                        parentSet.add(target);
                    }
                }
            });

            multiSelectedObjects = Array.from(parentSet);

            multiSelectedObjects.forEach(obj => {
                const helper = new THREE.BoxHelper(obj, 0xffff00);
                scene.add(helper);
                selectionHelpers.push(helper);
            });

            if (multiSelectedObjects.length > 0) {
                showStatus(`${multiSelectedObjects.length} itens selecionados.`);
                const btn = document.getElementById('btn-multi-delete');
                btn.innerHTML = `<span class="material-icons">delete_sweep</span> DELETAR ${multiSelectedObjects.length} ITENS`;
                btn.style.display = 'flex';
            } else {
                showStatus("Nenhum objeto na área.");
            }
        }

        function clearMultiSelection() {
            multiSelectedObjects = [];
            selectionHelpers.forEach(h => scene.remove(h));
            selectionHelpers = [];
            document.getElementById('btn-multi-delete').style.display = 'none';
        }

        function deleteMultiSelected() {
            if (multiSelectedObjects.length === 0) return;
            
            multiSelectedObjects.forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
                 if(obj.traverse) {
                    obj.traverse(child => {
                        if(child.geometry) child.geometry.dispose();
                        if(child.material) {
                            if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                            else child.material.dispose();
                        }
                    });
                }
            });
            
            showStatus(`${multiSelectedObjects.length} itens removidos!`);
            clearMultiSelection();
            saveHistory();
        }

        function selectObject(object) {
            if (boxSelectMode || drawMode || eraserMode) return; 

            selectedObject = object;
            transformControl.attach(object);
            transformControl.showY = !lockY;
            document.getElementById('properties-container').style.display = 'block';
            updateUIValues();
        }

        function deselect() {
            selectedObject = null;
            transformControl.detach();
            document.getElementById('properties-container').style.display = 'none';
        }

        function updateUIValues() {
            if(!selectedObject) return;
            
            const p = selectedObject.position;
            const s = selectedObject.scale;
            document.getElementById('inp-px').value = p.x.toFixed(2);
            document.getElementById('inp-py').value = p.y.toFixed(2);
            document.getElementById('inp-pz').value = p.z.toFixed(2);
            document.getElementById('inp-sx').value = s.x.toFixed(2);
            document.getElementById('inp-sy').value = s.y.toFixed(2);
            document.getElementById('inp-sz').value = s.z.toFixed(2);

            const heightRow = document.getElementById('row-extrusion');
            if (selectedObject.userData.isExtruded) {
                heightRow.style.display = 'flex';
                document.getElementById('inp-extrusion').value = selectedObject.userData.currentHeight || 0.1;
            } else {
                heightRow.style.display = 'none';
            }
        }

        function updateTransform(type) {
            if(!selectedObject) return;
            if(type === 'pos') {
                const x = parseFloat(document.getElementById('inp-px').value);
                const y = parseFloat(document.getElementById('inp-py').value);
                const z = parseFloat(document.getElementById('inp-pz').value);
                selectedObject.position.set(x, y, z);
            } else if (type === 'scale') {
                const x = parseFloat(document.getElementById('inp-sx').value);
                const y = parseFloat(document.getElementById('inp-sy').value);
                const z = parseFloat(document.getElementById('inp-sz').value);
                selectedObject.scale.set(x, y, z);
            }
            saveHistory();
        }

        function setMode(mode) {
            ['translate','rotate','scale', 'rotate-y'].forEach(m => {
                const el = document.getElementById('tool-'+m);
                if(el) el.classList.remove('active');
            });
            
            if (mode === 'rotate-y') {
                transformControl.setMode('rotate');
                transformControl.showX = false;
                transformControl.showZ = false;
                transformControl.showY = true;
                document.getElementById('tool-rotate-y').classList.add('active');
                showStatus("Rotação Travada no Chão (Eixo Y)");
                return;
            } else {
                transformControl.showX = true;
                transformControl.showZ = true;
                transformControl.showY = true;
            }

            transformControl.setMode(mode);
            document.getElementById('tool-'+mode).classList.add('active');
            
            if(mode === 'translate') {
                transformControl.showY = !lockY;
            }
        }

        function duplicateSelected() {
    if (!selectedObject) return;
    const clone = selectedObject.clone();
    clone.position.x += 2; 
    
    if (selectedObject.userData.isExtruded) {
        clone.userData.isExtruded = true;
        clone.userData.baseShape = selectedObject.userData.baseShape;
        
        // --- ADICIONE ESTA LINHA ---
        clone.userData.shapePoints = selectedObject.userData.shapePoints;
        // ---------------------------

        clone.userData.currentHeight = selectedObject.userData.currentHeight;
        clone.geometry = selectedObject.geometry.clone(); 
        if(clone.material.map) automapUVs(clone, true);
    }
    
    clone.userData.locked = false;

    selectedObject.parent.add(clone);
    selectObject(clone);
    showStatus("Objeto duplicado!");
    saveHistory();
}

        function deleteSelected() {
            if (!selectedObject) return;
            if(selectedObject.userData.listID) {
                const el = document.getElementById(selectedObject.userData.listID);
                if(el) el.remove();
            }
            
            const obj = selectedObject;
            obj.parent.remove(obj);
            if(obj.traverse) {
                obj.traverse(child => {
                    if(child.geometry) child.geometry.dispose();
                    if(child.material) {
                        if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                });
            }

            deselect();
            showStatus("Objeto removido.");
            saveHistory();
        }

        function onKeyDown(event) {
            if (event.target.tagName === 'INPUT') {
                if(event.key === 'Enter' && event.target.id === 'length-input-value') {
                    submitLengthInput();
                }
                return;
            }
            const key = event.key.toLowerCase();
            if (key === "delete") deleteSelected();
            if (event.ctrlKey && key === "d") { event.preventDefault(); duplicateSelected(); }
            if (event.ctrlKey && key === "z") { event.preventDefault(); undo(); }
            if (event.ctrlKey && key === "y") { event.preventDefault(); redo(); }
            
            if (key === "g") setMode('translate');
            if (key === "r") setMode('rotate');
            if (key === "s") setMode('scale');
        }

        function exportScene() {
            if (objectsGroup.children.length === 0) {
                showStatus("Cena vazia.");
                return;
            }
            
            deselect();
            clearMultiSelection();
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingMsg = document.getElementById('loading-msg');
            loadingOverlay.style.display = 'flex';
            loadingMsg.innerText = "OTIMIZANDO TEXTURAS...";

            setTimeout(() => {
                try {
                    const exportGroup = new THREE.Group();
                    
                    objectsGroup.children.forEach(child => {
                        if (child.visible && !child.userData.isGhost) {
                            const clone = child.clone();
                            optimizeModelForExport(clone);
                            exportGroup.add(clone);
                        }
                    });

                    loadingMsg.innerText = "GERANDO GLB...";

                    const exporter = new THREE.GLTFExporter();
                    exporter.parse(exportGroup, function (result) {
                        
                        const blob = new Blob([result], { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'cenario_otimizado.glb';
                        a.click();
                        
                        loadingOverlay.style.display = 'none';
                        showStatus("Exportado com Sucesso!");
                        
                    }, { 
                        binary: true, 
                        onlyVisible: true,
                        embedImages: true 
                    });

                } catch (e) {
                    console.error("Erro na exportação:", e);
                    loadingOverlay.style.display = 'none';
                    alert("Erro ao exportar: " + e.message);
                }
            }, 100);
        }

        function optimizeModelForExport(object) {
            object.traverse((node) => {
                if (node.isMesh && node.material) {
                    const materials = Array.isArray(node.material) ? node.material : [node.material];
                    
                    materials.forEach(mat => {
                        if (mat.map && mat.map.image) {
                            const newTexture = resizeTexture(mat.map);
                            const newMat = mat.clone();
                            newMat.map = newTexture;
                            if (Array.isArray(node.material)) {
                                const idx = node.material.indexOf(mat);
                                node.material[idx] = newMat;
                            } else {
                                node.material = newMat;
                            }
                        }
                    });
                }
            });
        }

        const textureCache = new Map();

        function resizeTexture(originalTexture) {
            if (!originalTexture.image) return originalTexture;
            
            if (textureCache.has(originalTexture.uuid)) {
                return textureCache.get(originalTexture.uuid);
            }

            const MAX_SIZE = 1024; 
            
            const image = originalTexture.image;
            let width = image.width;
            let height = image.height;

            if (width <= MAX_SIZE && height <= MAX_SIZE) {
                return originalTexture;
            }

            if (width > height) {
                if (width > MAX_SIZE) {
                    height *= MAX_SIZE / width;
                    width = MAX_SIZE;
                }
            } else {
                if (height > MAX_SIZE) {
                    width *= MAX_SIZE / height;
                    height = MAX_SIZE;
                }
            }

            const canvas = document.createElement('canvas');
            canvas.width = Math.floor(width);
            canvas.height = Math.floor(height);
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(image, 0, 0, width, height);

            const newTexture = new THREE.CanvasTexture(canvas);
            
            newTexture.wrapS = originalTexture.wrapS;
            newTexture.wrapT = originalTexture.wrapT;
            newTexture.repeat.copy(originalTexture.repeat);
            newTexture.offset.copy(originalTexture.offset);
            newTexture.encoding = THREE.sRGBEncoding; 
            newTexture.flipY = originalTexture.flipY; 
            newTexture.name = originalTexture.name || "optimized_tex";
            
            textureCache.set(originalTexture.uuid, newTexture);
            return newTexture;
        }

        function showStatus(msg) {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, 4000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function undoLastDrawPoint() {
            if (drawingPoints.length === 0) {
                showStatus("Nenhum ponto para desfazer.");
                return;
            }

            drawingPoints.pop();

            if (drawingLines.length > 0) {
                const lastLine = drawingLines.pop();
                scene.remove(lastLine);
                if (lastLine.geometry) lastLine.geometry.dispose();
            }

            if (tempLine) {
                scene.remove(tempLine);
                tempLine = null;
            }
            
            if (drawingPoints.length < 3) {
                document.getElementById('btn-finish-poly').style.display = 'none';
            }

            // Se estava no meio de um arco, cancela o arco
            if (arcIntermediatePoint) {
                arcIntermediatePoint = null;
                if(arcPreviewLine) scene.remove(arcPreviewLine);
            }

            showStatus("Ponto removido.");
        }

        function clearAllGeoJSON() {
            if (!confirm("Tem certeza que deseja excluir todo o gabarito (GeoJSON e Desenhos)?")) return;

            const importedMap = objectsGroup.children.find(c => c.name === "Mapa Importado (GeoJSON)");
            if (importedMap) {
                objectsGroup.remove(importedMap);
                if(importedMap.userData.listID) {
                    const el = document.getElementById(importedMap.userData.listID);
                    if(el) el.remove();
                }
            }

            while(geoJsonGhostGroup.children.length > 0){ 
                geoJsonGhostGroup.remove(geoJsonGhostGroup.children[0]); 
            }

            drawnPolygons.forEach(polyData => {
                const obj = objectsGroup.children.find(c => c.uuid === polyData.uuid);
                if (obj) {
                    objectsGroup.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                }
            });

            drawnPolygons = [];
            
            cancelDrawing();
            showStatus("Gabarito e desenhos excluídos.");
            saveHistory();
        }

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
